/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, Validators, FormGroup } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MomentDateAdapter, MOMENT_DATE_FORMATS } from '@alfresco/adf-core';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
import { UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
/** @type {?} */
const DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
const ɵ0 = MOMENT_DATE_FORMATS;
export class SearchDateRangeComponent {
    /**
     * @param {?} dateAdapter
     * @param {?} userPreferencesService
     */
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.datePickerDateFormat = DEFAULT_FORMAT_DATE;
        this.onDestroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    getFromValidationMessage() {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    }
    /**
     * @return {?}
     */
    getToValidationMessage() {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        if (this.settings) {
            this.datePickerDateFormat = this.settings.dateFormat || DEFAULT_FORMAT_DATE;
        }
        /** @type {?} */
        const theCustomDateAdapter = (/** @type {?} */ ((/** @type {?} */ (this.dateAdapter))));
        theCustomDateAdapter.overrideDisplayFormat = this.datePickerDateFormat;
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        locale => this.setLocale(locale)));
        /** @type {?} */
        const validators = Validators.compose([
            Validators.required
        ]);
        this.from = new FormControl('', validators);
        this.to = new FormControl('', validators);
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.maxDate = this.dateAdapter.today().startOf('day');
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    /**
     * @param {?} model
     * @param {?} isValid
     * @return {?}
     */
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            /** @type {?} */
            const start = moment(model.from).startOf('day').format();
            /** @type {?} */
            const end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = `${this.settings.field}:['${start}' TO '${end}']`;
            this.context.update();
        }
    }
    /**
     * @return {?}
     */
    reset() {
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            this.context.update();
        }
    }
    /**
     * @param {?} event
     * @param {?} formControl
     * @return {?}
     */
    onChangedHandler(event, formControl) {
        /** @type {?} */
        const inputValue = event.srcElement.value;
        /** @type {?} */
        const formatDate = this.dateAdapter.parse(inputValue, this.datePickerDateFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        else {
            formControl.setErrors({
                'required': true
            });
        }
    }
    /**
     * @param {?} locale
     * @return {?}
     */
    setLocale(locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    }
    /**
     * @param {?} formControl
     * @return {?}
     */
    hasParseError(formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    forcePlaceholder(event) {
        event.srcElement.click();
    }
}
SearchDateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-date-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"date-range-from-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\" data-automation-id=\"date-range-from-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"date-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (focusout)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"date-range-to-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\" data-automation-id=\"date-range-to-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"date-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerDateFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"reset()\" data-automation-id=\"date-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"date-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-date-range' },
                styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            }] }
];
/** @nocollapse */
SearchDateRangeComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
if (false) {
    /** @type {?} */
    SearchDateRangeComponent.prototype.from;
    /** @type {?} */
    SearchDateRangeComponent.prototype.to;
    /** @type {?} */
    SearchDateRangeComponent.prototype.form;
    /** @type {?} */
    SearchDateRangeComponent.prototype.matcher;
    /** @type {?} */
    SearchDateRangeComponent.prototype.id;
    /** @type {?} */
    SearchDateRangeComponent.prototype.settings;
    /** @type {?} */
    SearchDateRangeComponent.prototype.context;
    /** @type {?} */
    SearchDateRangeComponent.prototype.maxDate;
    /** @type {?} */
    SearchDateRangeComponent.prototype.datePickerDateFormat;
    /**
     * @type {?}
     * @private
     */
    SearchDateRangeComponent.prototype.onDestroy$;
    /**
     * @type {?}
     * @private
     */
    SearchDateRangeComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    SearchDateRangeComponent.prototype.userPreferencesService;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb250ZW50LXNlcnZpY2VzLyIsInNvdXJjZXMiOlsic2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWRhdGUtcmFuZ2Uvc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUJBLE9BQU8sRUFBVSxTQUFTLEVBQUUsaUJBQWlCLEVBQWEsTUFBTSxlQUFlLENBQUM7QUFDaEYsT0FBTyxFQUFFLFdBQVcsRUFBRSxVQUFVLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxlQUFlLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RixPQUFPLEVBQUUsaUJBQWlCLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUs1RSxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUU3RSxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUNsRixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7TUFJckMsbUJBQW1CLEdBQVcsWUFBWTtXQVFGLG1CQUFtQjtBQUtqRSxNQUFNLE9BQU8sd0JBQXdCOzs7OztJQWdCakMsWUFBb0IsV0FBZ0MsRUFDaEMsc0JBQThDO1FBRDlDLGdCQUFXLEdBQVgsV0FBVyxDQUFxQjtRQUNoQywyQkFBc0IsR0FBdEIsc0JBQXNCLENBQXdCO1FBWGxFLFlBQU8sR0FBRyxJQUFJLHFCQUFxQixFQUFFLENBQUM7UUFNdEMseUJBQW9CLEdBQUcsbUJBQW1CLENBQUM7UUFFbkMsZUFBVSxHQUFHLElBQUksT0FB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LHNDQUFnQjs7SUFFaEIsd0NBQWdCOztJQUNoQiwyQ0FBc0M7O0lBRXRDLHNDQUFXOztJQUNYLDRDQUFnQzs7SUFDaEMsMkNBQW9DOztJQUNwQywyQ0FBYTs7SUFDYix3REFBMkM7Ozs7O0lBRTNDLDhDQUE0Qzs7Ozs7SUFFaEMsK0NBQXdDOzs7OztJQUN4QywwREFBc0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBPbkluaXQsIENvbXBvbmVudCwgVmlld0VuY2Fwc3VsYXRpb24sIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIFZhbGlkYXRvcnMsIEZvcm1Hcm91cCB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTLCBNQVRfREFURV9MT0NBTEUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyLCBNT01FTlRfREFURV9GT1JNQVRTIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vc2VhcmNoLXdpZGdldC5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0U2V0dGluZ3MgfSBmcm9tICcuLi8uLi9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICcuLi8uLi9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXInO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsIFVzZXJQcmVmZXJlbmNlVmFsdWVzIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZGVjbGFyZSBsZXQgbW9tZW50OiBhbnk7XG5cbmNvbnN0IERFRkFVTFRfRk9STUFUX0RBVEU6IHN0cmluZyA9ICdERC9NTS9ZWVlZJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtc2VhcmNoLWRhdGUtcmFuZ2UnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9zZWFyY2gtZGF0ZS1yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnNjc3MnXSxcbiAgICBwcm92aWRlcnM6IFtcbiAgICAgICAge3Byb3ZpZGU6IERhdGVBZGFwdGVyLCB1c2VDbGFzczogTW9tZW50RGF0ZUFkYXB0ZXIsIGRlcHM6IFtNQVRfREFURV9MT0NBTEVdfSxcbiAgICAgICAge3Byb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTfVxuICAgIF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC1kYXRlLXJhbmdlJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGVSYW5nZUNvbXBvbmVudCBpbXBsZW1lbnRzIFNlYXJjaFdpZGdldCwgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgZnJvbTogRm9ybUNvbnRyb2w7XG4gICAgdG86IEZvcm1Db250cm9sO1xuXG4gICAgZm9ybTogRm9ybUdyb3VwO1xuICAgIG1hdGNoZXIgPSBuZXcgTGl2ZUVycm9yU3RhdGVNYXRjaGVyKCk7XG5cbiAgICBpZDogc3RyaW5nO1xuICAgIHNldHRpbmdzPzogU2VhcmNoV2lkZ2V0U2V0dGluZ3M7XG4gICAgY29udGV4dD86IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2U7XG4gICAgbWF4RGF0ZTogYW55O1xuICAgIGRhdGVQaWNrZXJEYXRlRm9ybWF0ID0gREVGQVVMVF9GT1JNQVRfREFURTtcblxuICAgIHByaXZhdGUgb25EZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIGdldEZyb21WYWxpZGF0aW9uTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy5mcm9tKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJNYXgnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uQkVZT05ELU1BWC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ3JlcXVpcmVkJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLlJFUVVJUkVELVZBTFVFJyA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG5cbiAgICBnZXRUb1ZhbGlkYXRpb25NZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy50bykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLklOVkFMSUQtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1pbicpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5OTy1EQVlTJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcigncmVxdWlyZWQnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uUkVRVUlSRUQtVkFMVUUnIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncykge1xuICAgICAgICAgICAgdGhpcy5kYXRlUGlja2VyRGF0ZUZvcm1hdCA9IHRoaXMuc2V0dGluZ3MuZGF0ZUZvcm1hdCB8fCBERUZBVUxUX0ZPUk1BVF9EQVRFO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRoZUN1c3RvbURhdGVBZGFwdGVyID0gPE1vbWVudERhdGVBZGFwdGVyPiA8YW55PiB0aGlzLmRhdGVBZGFwdGVyO1xuICAgICAgICB0aGVDdXN0b21EYXRlQWRhcHRlci5vdmVycmlkZURpc3BsYXlGb3JtYXQgPSB0aGlzLmRhdGVQaWNrZXJEYXRlRm9ybWF0O1xuXG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZVxuICAgICAgICAgICAgLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHRoaXMuc2V0TG9jYWxlKGxvY2FsZSkpO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZFxuICAgICAgICBdKTtcblxuICAgICAgICB0aGlzLmZyb20gPSBuZXcgRm9ybUNvbnRyb2woJycsIHZhbGlkYXRvcnMpO1xuICAgICAgICB0aGlzLnRvID0gbmV3IEZvcm1Db250cm9sKCcnLCB2YWxpZGF0b3JzKTtcblxuICAgICAgICB0aGlzLmZvcm0gPSBuZXcgRm9ybUdyb3VwKHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZnJvbSxcbiAgICAgICAgICAgIHRvOiB0aGlzLnRvXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubWF4RGF0ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIudG9kYXkoKS5zdGFydE9mKCdkYXknKTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsOiB7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9LCBpc1ZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5maWVsZCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBtb21lbnQobW9kZWwuZnJvbSkuc3RhcnRPZignZGF5JykuZm9ybWF0KCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBtb21lbnQobW9kZWwudG8pLmVuZE9mKCdkYXknKS5mb3JtYXQoKTtcblxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gYCR7dGhpcy5zZXR0aW5ncy5maWVsZH06Wycke3N0YXJ0fScgVE8gJyR7ZW5kfSddYDtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC51cGRhdGUoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLmZvcm0ucmVzZXQoe1xuICAgICAgICAgICAgZnJvbTogJycsXG4gICAgICAgICAgICB0bzogJydcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmlkICYmIHRoaXMuY29udGV4dCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnF1ZXJ5RnJhZ21lbnRzW3RoaXMuaWRdID0gJyc7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbkNoYW5nZWRIYW5kbGVyKGV2ZW50OiBhbnksIGZvcm1Db250cm9sOiBGb3JtQ29udHJvbCkge1xuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gZXZlbnQuc3JjRWxlbWVudC52YWx1ZTtcblxuICAgICAgICBjb25zdCBmb3JtYXREYXRlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShpbnB1dFZhbHVlLCB0aGlzLmRhdGVQaWNrZXJEYXRlRm9ybWF0KTtcbiAgICAgICAgaWYgKGZvcm1hdERhdGUgJiYgZm9ybWF0RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnNldFZhbHVlKGZvcm1hdERhdGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGZvcm1hdERhdGUpIHtcbiAgICAgICAgICAgIGZvcm1Db250cm9sLnNldEVycm9ycyh7XG4gICAgICAgICAgICAgICAgJ2ludmFsaWRPbkNoYW5nZSc6IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0RXJyb3JzKHtcbiAgICAgICAgICAgICAgICAncmVxdWlyZWQnOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgbW9tZW50LmxvY2FsZShsb2NhbGUpO1xuICAgIH1cblxuICAgIGhhc1BhcnNlRXJyb3IoZm9ybUNvbnRyb2wpIHtcbiAgICAgICAgcmV0dXJuIGZvcm1Db250cm9sLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyUGFyc2UnKSAmJiBmb3JtQ29udHJvbC5nZXRFcnJvcignbWF0RGF0ZXBpY2tlclBhcnNlJykudGV4dDtcbiAgICB9XG5cbiAgICBmb3JjZVBsYWNlaG9sZGVyKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgZXZlbnQuc3JjRWxlbWVudC5jbGljaygpO1xuICAgIH1cblxufVxuIl19