/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { DatePipe } from '@angular/common';
import { Pipe } from '@angular/core';
import { AppConfigService } from '../app-config/app-config.service';
import { UserPreferencesService, UserPreferenceValues } from '../services/user-preferences.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
var LocalizedDatePipe = /** @class */ (function () {
    function LocalizedDatePipe(userPreferenceService, appConfig) {
        var _this = this;
        this.userPreferenceService = userPreferenceService;
        this.appConfig = appConfig;
        this.defaultLocale = LocalizedDatePipe.DEFAULT_LOCALE;
        this.defaultFormat = LocalizedDatePipe.DEFAULT_DATE_FORMAT;
        this.onDestroy$ = new Subject();
        if (this.userPreferenceService) {
            this.userPreferenceService
                .select(UserPreferenceValues.Locale)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe((/**
             * @param {?} locale
             * @return {?}
             */
            function (locale) {
                if (locale) {
                    _this.defaultLocale = locale;
                }
            }));
        }
        if (this.appConfig) {
            this.defaultFormat = this.appConfig.get('dateValues.defaultDateFormat', LocalizedDatePipe.DEFAULT_DATE_FORMAT);
        }
    }
    /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    LocalizedDatePipe.prototype.transform = /**
     * @param {?} value
     * @param {?=} format
     * @param {?=} locale
     * @return {?}
     */
    function (value, format, locale) {
        /** @type {?} */
        var actualFormat = format || this.defaultFormat;
        /** @type {?} */
        var actualLocale = locale || this.defaultLocale;
        /** @type {?} */
        var datePipe = new DatePipe(actualLocale);
        return datePipe.transform(value, actualFormat);
    };
    /**
     * @return {?}
     */
    LocalizedDatePipe.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    };
    LocalizedDatePipe.DEFAULT_LOCALE = 'en-US';
    LocalizedDatePipe.DEFAULT_DATE_FORMAT = 'mediumDate';
    LocalizedDatePipe.decorators = [
        { type: Pipe, args: [{
                    name: 'adfLocalizedDate',
                    pure: false
                },] }
    ];
    /** @nocollapse */
    LocalizedDatePipe.ctorParameters = function () { return [
        { type: UserPreferencesService },
        { type: AppConfigService }
    ]; };
    return LocalizedDatePipe;
}());
export { LocalizedDatePipe };
if (false) {
    /** @type {?} */
    LocalizedDatePipe.DEFAULT_LOCALE;
    /** @type {?} */
    LocalizedDatePipe.DEFAULT_DATE_FORMAT;
    /** @type {?} */
    LocalizedDatePipe.prototype.defaultLocale;
    /** @type {?} */
    LocalizedDatePipe.prototype.defaultFormat;
    /**
     * @type {?}
     * @private
     */
    LocalizedDatePipe.prototype.onDestroy$;
    /** @type {?} */
    LocalizedDatePipe.prototype.userPreferenceService;
    /** @type {?} */
    LocalizedDatePipe.prototype.appConfig;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxpemVkLWRhdGUucGlwZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbInBpcGVzL2xvY2FsaXplZC1kYXRlLnBpcGUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFpQkEsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxJQUFJLEVBQTRCLE1BQU0sZUFBZSxDQUFDO0FBQy9ELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3BHLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRTNDO0lBY0ksMkJBQW1CLHFCQUE4QyxFQUM5QyxTQUE0QjtRQUQvQyxpQkFpQkM7UUFqQmtCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBeUI7UUFDOUMsY0FBUyxHQUFULFNBQVMsQ0FBbUI7UUFOL0Msa0JBQWEsR0FBVyxpQkFBaUIsQ0FBQyxjQUFjLENBQUM7UUFDekQsa0JBQWEsR0FBVyxpQkFBaUIsQ0FBQyxtQkFBbUIsQ0FBQztRQUV0RCxlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztRQUt4QyxJQUFJLElBQUksQ0FBQyxxQkFBcUIsRUFBRTtZQUM1QixJQUFJLENBQUMscUJBQXFCO2lCQUNyQixNQUFNLENBQUMsb0JBQW9CLENBQUMsTUFBTSxDQUFDO2lCQUNuQyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztpQkFDaEMsU0FBUzs7OztZQUFDLFVBQUEsTUFBTTtnQkFDYixJQUFJLE1BQU0sRUFBRTtvQkFDUixLQUFJLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQztpQkFDL0I7WUFDTCxDQUFDLEVBQUMsQ0FBQztTQUNWO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFO1lBQ2hCLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FBQyxHQUFHLENBQVMsOEJBQThCLEVBQUUsaUJBQWlCLENBQUMsbUJBQW1CLENBQUMsQ0FBQztTQUMxSDtJQUNMLENBQUM7Ozs7Ozs7SUFFRCxxQ0FBUzs7Ozs7O0lBQVQsVUFBVSxLQUFVLEVBQUUsTUFBZSxFQUFFLE1BQWU7O1lBQzVDLFlBQVksR0FBRyxNQUFNLElBQUksSUFBSSxDQUFDLGFBQWE7O1lBQzNDLFlBQVksR0FBRyxNQUFNLElBQUksSUFBSSxDQUFDLGFBQWE7O1lBQzNDLFFBQVEsR0FBYSxJQUFJLFFBQVEsQ0FBQyxZQUFZLENBQUM7UUFDckQsT0FBTyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxZQUFZLENBQUMsQ0FBQztJQUNuRCxDQUFDOzs7O0lBRUQsdUNBQVc7OztJQUFYO1FBQ0ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDM0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztJQUMvQixDQUFDO0lBckNNLGdDQUFjLEdBQUcsT0FBTyxDQUFDO0lBQ3pCLHFDQUFtQixHQUFHLFlBQVksQ0FBQzs7Z0JBUDdDLElBQUksU0FBQztvQkFDRixJQUFJLEVBQUUsa0JBQWtCO29CQUN4QixJQUFJLEVBQUUsS0FBSztpQkFDZDs7OztnQkFQUSxzQkFBc0I7Z0JBRHRCLGdCQUFnQjs7SUFrRHpCLHdCQUFDO0NBQUEsQUE3Q0QsSUE2Q0M7U0F6Q1ksaUJBQWlCOzs7SUFFMUIsaUNBQWdDOztJQUNoQyxzQ0FBMEM7O0lBRTFDLDBDQUF5RDs7SUFDekQsMENBQThEOzs7OztJQUU5RCx1Q0FBNEM7O0lBRWhDLGtEQUFxRDs7SUFDckQsc0NBQW1DIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGF0ZVBpcGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBcHBDb25maWdTZXJ2aWNlIH0gZnJvbSAnLi4vYXBwLWNvbmZpZy9hcHAtY29uZmlnLnNlcnZpY2UnO1xuaW1wb3J0IHsgVXNlclByZWZlcmVuY2VzU2VydmljZSwgVXNlclByZWZlcmVuY2VWYWx1ZXMgfSBmcm9tICcuLi9zZXJ2aWNlcy91c2VyLXByZWZlcmVuY2VzLnNlcnZpY2UnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2FkZkxvY2FsaXplZERhdGUnLFxuICAgIHB1cmU6IGZhbHNlXG59KVxuZXhwb3J0IGNsYXNzIExvY2FsaXplZERhdGVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSwgT25EZXN0cm95IHtcblxuICAgIHN0YXRpYyBERUZBVUxUX0xPQ0FMRSA9ICdlbi1VUyc7XG4gICAgc3RhdGljIERFRkFVTFRfREFURV9GT1JNQVQgPSAnbWVkaXVtRGF0ZSc7XG5cbiAgICBkZWZhdWx0TG9jYWxlOiBzdHJpbmcgPSBMb2NhbGl6ZWREYXRlUGlwZS5ERUZBVUxUX0xPQ0FMRTtcbiAgICBkZWZhdWx0Rm9ybWF0OiBzdHJpbmcgPSBMb2NhbGl6ZWREYXRlUGlwZS5ERUZBVUxUX0RBVEVfRk9STUFUO1xuXG4gICAgcHJpdmF0ZSBvbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyB1c2VyUHJlZmVyZW5jZVNlcnZpY2U/OiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHB1YmxpYyBhcHBDb25maWc/OiBBcHBDb25maWdTZXJ2aWNlKSB7XG5cbiAgICAgICAgaWYgKHRoaXMudXNlclByZWZlcmVuY2VTZXJ2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLnVzZXJQcmVmZXJlbmNlU2VydmljZVxuICAgICAgICAgICAgICAgIC5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKVxuICAgICAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvY2FsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZhdWx0TG9jYWxlID0gbG9jYWxlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5hcHBDb25maWcpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmYXVsdEZvcm1hdCA9IHRoaXMuYXBwQ29uZmlnLmdldDxzdHJpbmc+KCdkYXRlVmFsdWVzLmRlZmF1bHREYXRlRm9ybWF0JywgTG9jYWxpemVkRGF0ZVBpcGUuREVGQVVMVF9EQVRFX0ZPUk1BVCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0cmFuc2Zvcm0odmFsdWU6IGFueSwgZm9ybWF0Pzogc3RyaW5nLCBsb2NhbGU/OiBzdHJpbmcpOiBhbnkge1xuICAgICAgICBjb25zdCBhY3R1YWxGb3JtYXQgPSBmb3JtYXQgfHwgdGhpcy5kZWZhdWx0Rm9ybWF0O1xuICAgICAgICBjb25zdCBhY3R1YWxMb2NhbGUgPSBsb2NhbGUgfHwgdGhpcy5kZWZhdWx0TG9jYWxlO1xuICAgICAgICBjb25zdCBkYXRlUGlwZTogRGF0ZVBpcGUgPSBuZXcgRGF0ZVBpcGUoYWN0dWFsTG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIGRhdGVQaXBlLnRyYW5zZm9ybSh2YWx1ZSwgYWN0dWFsRm9ybWF0KTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxufVxuIl19