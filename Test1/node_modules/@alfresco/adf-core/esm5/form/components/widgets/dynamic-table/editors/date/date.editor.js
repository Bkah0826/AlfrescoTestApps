/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
import { UserPreferencesService, UserPreferenceValues } from '../../../../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../../../../utils/momentDateAdapter';
import { MOMENT_DATE_FORMATS } from '../../../../../../utils/moment-date-formats.model';
import { Component, Input } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material';
import moment from 'moment-es6';
import { DynamicTableModel } from './../../dynamic-table.widget.model';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
var ɵ0 = MOMENT_DATE_FORMATS;
var DateEditorComponent = /** @class */ (function () {
    function DateEditorComponent(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'DD-MM-YYYY';
        this.onDestroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    DateEditorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} locale
         * @return {?}
         */
        function (locale) { return _this.dateAdapter.setLocale(locale); }));
        /** @type {?} */
        var momentDateAdapter = (/** @type {?} */ (this.dateAdapter));
        momentDateAdapter.overrideDisplayFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    };
    /**
     * @return {?}
     */
    DateEditorComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    };
    /**
     * @param {?} newDateValue
     * @return {?}
     */
    DateEditorComponent.prototype.onDateChanged = /**
     * @param {?} newDateValue
     * @return {?}
     */
    function (newDateValue) {
        if (newDateValue && newDateValue.value) {
            /* validates the user inputs */
            /** @type {?} */
            var momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = newDateValue.value;
            }
            else {
                this.row.value[this.column.id] = momentDate.format('YYYY-MM-DD') + "T00:00:00.000Z";
                this.table.flushValue();
            }
        }
        else {
            /* removes the date  */
            this.row.value[this.column.id] = '';
        }
    };
    DateEditorComponent.decorators = [
        { type: Component, args: [{
                    selector: 'adf-date-editor',
                    template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} ({{DATE_FORMAT}})</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($event.srcElement)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                    providers: [
                        { provide: DateAdapter, useClass: MomentDateAdapter },
                        { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                    ],
                    styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
                }] }
    ];
    /** @nocollapse */
    DateEditorComponent.ctorParameters = function () { return [
        { type: DateAdapter },
        { type: UserPreferencesService }
    ]; };
    DateEditorComponent.propDecorators = {
        table: [{ type: Input }],
        row: [{ type: Input }],
        column: [{ type: Input }]
    };
    return DateEditorComponent;
}());
export { DateEditorComponent };
if (false) {
    /** @type {?} */
    DateEditorComponent.prototype.DATE_FORMAT;
    /** @type {?} */
    DateEditorComponent.prototype.value;
    /** @type {?} */
    DateEditorComponent.prototype.table;
    /** @type {?} */
    DateEditorComponent.prototype.row;
    /** @type {?} */
    DateEditorComponent.prototype.column;
    /** @type {?} */
    DateEditorComponent.prototype.minDate;
    /** @type {?} */
    DateEditorComponent.prototype.maxDate;
    /**
     * @type {?}
     * @private
     */
    DateEditorComponent.prototype.onDestroy$;
    /**
     * @type {?}
     * @private
     */
    DateEditorComponent.prototype.dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DateEditorComponent.prototype.userPreferencesService;
}
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5lZGl0b3IuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYWxmcmVzY28vYWRmLWNvcmUvIiwic291cmNlcyI6WyJmb3JtL2NvbXBvbmVudHMvd2lkZ2V0cy9keW5hbWljLXRhYmxlL2VkaXRvcnMvZGF0ZS9kYXRlLmVkaXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsT0FBTyxFQUFFLHNCQUFzQixFQUFFLG9CQUFvQixFQUFFLE1BQU0scURBQXFELENBQUM7QUFFbkgsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMkNBQTJDLENBQUM7QUFDOUUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbURBQW1ELENBQUM7QUFDeEYsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQXFCLE1BQU0sZUFBZSxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQTJCLE1BQU0sbUJBQW1CLENBQUM7QUFDM0YsT0FBTyxNQUFNLE1BQU0sWUFBWSxDQUFDO0FBSWhDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3ZFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO1NBT0csbUJBQW1CO0FBTGpFO0lBNEJJLDZCQUFvQixXQUFnQyxFQUNoQyxzQkFBOEM7UUFEOUMsZ0JBQVcsR0FBWCxXQUFXLENBQXFCO1FBQ2hDLDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFuQmxFLGdCQUFXLEdBQVcsWUFBWSxDQUFDO1FBZ0IzQixlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQVcsQ0FBQztJQUk1QyxDQUFDOzs7O0lBRUQsc0NBQVE7OztJQUFSO1FBQUEsaUJBVUM7UUFURyxJQUFJLENBQUMsc0JBQXNCO2FBQ3RCLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7YUFDbkMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDaEMsU0FBUzs7OztRQUFDLFVBQUEsTUFBTSxJQUFJLE9BQUEsS0FBSSxDQUFDLFdBQVcsQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLEVBQWxDLENBQWtDLEVBQUMsQ0FBQzs7WUFFdkQsaUJBQWlCLEdBQUcsbUJBQW9CLElBQUksQ0FBQyxXQUFXLEVBQUE7UUFDOUQsaUJBQWlCLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztRQUUzRCxJQUFJLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDMUYsQ0FBQzs7OztJQUVELHlDQUFXOzs7SUFBWDtRQUNJLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzNCLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7SUFDL0IsQ0FBQzs7Ozs7SUFFRCwyQ0FBYTs7OztJQUFiLFVBQWMsWUFBNkQ7UUFDdkUsSUFBSSxZQUFZLElBQUksWUFBWSxDQUFDLEtBQUssRUFBRTs7O2dCQUU5QixVQUFVLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxLQUFLLEVBQUUsSUFBSSxDQUFDLFdBQVcsRUFBRSxJQUFJLENBQUM7WUFFckUsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDdkIsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBSSxZQUFZLENBQUMsS0FBSyxDQUFDO2FBQ3hEO2lCQUFNO2dCQUNILElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQU0sVUFBVSxDQUFDLE1BQU0sQ0FBQyxZQUFZLENBQUMsbUJBQWdCLENBQUM7Z0JBQ3BGLElBQUksQ0FBQyxLQUFLLENBQUMsVUFBVSxFQUFFLENBQUM7YUFDM0I7U0FDSjthQUFNO1lBQ0gsdUJBQXVCO1lBQ3ZCLElBQUksQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1NBQ3ZDO0lBQ0wsQ0FBQzs7Z0JBaEVKLFNBQVMsU0FBQztvQkFDUCxRQUFRLEVBQUUsaUJBQWlCO29CQUMzQix3eEJBQWlDO29CQUNqQyxTQUFTLEVBQUU7d0JBQ1AsRUFBQyxPQUFPLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBQzt3QkFDbkQsRUFBQyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsUUFBUSxJQUFxQixFQUFDO3FCQUFDOztpQkFFbEU7Ozs7Z0JBaEJRLFdBQVc7Z0JBTFgsc0JBQXNCOzs7d0JBNEIxQixLQUFLO3NCQUdMLEtBQUs7eUJBR0wsS0FBSzs7SUE4Q1YsMEJBQUM7Q0FBQSxBQWxFRCxJQWtFQztTQTFEWSxtQkFBbUI7OztJQUU1QiwwQ0FBbUM7O0lBRW5DLG9DQUFXOztJQUVYLG9DQUN5Qjs7SUFFekIsa0NBQ3FCOztJQUVyQixxQ0FDMkI7O0lBRTNCLHNDQUFnQjs7SUFDaEIsc0NBQWdCOzs7OztJQUVoQix5Q0FBNEM7Ozs7O0lBRWhDLDBDQUF3Qzs7Ozs7SUFDeEMscURBQXNEIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLCBVc2VyUHJlZmVyZW5jZVZhbHVlcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3NlcnZpY2VzL3VzZXItcHJlZmVyZW5jZXMuc2VydmljZSc7XG5cbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdXRpbHMvbW9tZW50RGF0ZUFkYXB0ZXInO1xuaW1wb3J0IHsgTU9NRU5UX0RBVEVfRk9STUFUUyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3V0aWxzL21vbWVudC1kYXRlLWZvcm1hdHMubW9kZWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0LCBPbkRlc3Ryb3kgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTLCBNYXREYXRlcGlja2VySW5wdXRFdmVudCB9IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsJztcbmltcG9ydCBtb21lbnQgZnJvbSAnbW9tZW50LWVzNic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlQ29sdW1uIH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLWNvbHVtbi5tb2RlbCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVSb3cgfSBmcm9tICcuLy4uLy4uL2R5bmFtaWMtdGFibGUtcm93Lm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZU1vZGVsIH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLndpZGdldC5tb2RlbCc7XG5pbXBvcnQgeyBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRhdGUtZWRpdG9yJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vZGF0ZS5lZGl0b3IuaHRtbCcsXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBEYXRlQWRhcHRlciwgdXNlQ2xhc3M6IE1vbWVudERhdGVBZGFwdGVyfSxcbiAgICAgICAge3Byb3ZpZGU6IE1BVF9EQVRFX0ZPUk1BVFMsIHVzZVZhbHVlOiBNT01FTlRfREFURV9GT1JNQVRTfV0sXG4gICAgc3R5bGVVcmxzOiBbJy4vZGF0ZS5lZGl0b3Iuc2NzcyddXG59KVxuZXhwb3J0IGNsYXNzIERhdGVFZGl0b3JDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBEQVRFX0ZPUk1BVDogc3RyaW5nID0gJ0RELU1NLVlZWVknO1xuXG4gICAgdmFsdWU6IGFueTtcblxuICAgIEBJbnB1dCgpXG4gICAgdGFibGU6IER5bmFtaWNUYWJsZU1vZGVsO1xuXG4gICAgQElucHV0KClcbiAgICByb3c6IER5bmFtaWNUYWJsZVJvdztcblxuICAgIEBJbnB1dCgpXG4gICAgY29sdW1uOiBEeW5hbWljVGFibGVDb2x1bW47XG5cbiAgICBtaW5EYXRlOiBNb21lbnQ7XG4gICAgbWF4RGF0ZTogTW9tZW50O1xuXG4gICAgcHJpdmF0ZSBvbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGVBZGFwdGVyPE1vbWVudD4sXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSB1c2VyUHJlZmVyZW5jZXNTZXJ2aWNlOiBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZVxuICAgICAgICAgICAgLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSkpO1xuXG4gICAgICAgIGNvbnN0IG1vbWVudERhdGVBZGFwdGVyID0gPE1vbWVudERhdGVBZGFwdGVyPiB0aGlzLmRhdGVBZGFwdGVyO1xuICAgICAgICBtb21lbnREYXRlQWRhcHRlci5vdmVycmlkZURpc3BsYXlGb3JtYXQgPSB0aGlzLkRBVEVfRk9STUFUO1xuXG4gICAgICAgIHRoaXMudmFsdWUgPSBtb21lbnQodGhpcy50YWJsZS5nZXRDZWxsVmFsdWUodGhpcy5yb3csIHRoaXMuY29sdW1uKSwgdGhpcy5EQVRFX0ZPUk1BVCk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBvbkRhdGVDaGFuZ2VkKG5ld0RhdGVWYWx1ZTogTWF0RGF0ZXBpY2tlcklucHV0RXZlbnQ8YW55PiB8IEhUTUxJbnB1dEVsZW1lbnQpIHtcbiAgICAgICAgaWYgKG5ld0RhdGVWYWx1ZSAmJiBuZXdEYXRlVmFsdWUudmFsdWUpIHtcbiAgICAgICAgICAgIC8qIHZhbGlkYXRlcyB0aGUgdXNlciBpbnB1dHMgKi9cbiAgICAgICAgICAgIGNvbnN0IG1vbWVudERhdGUgPSBtb21lbnQobmV3RGF0ZVZhbHVlLnZhbHVlLCB0aGlzLkRBVEVfRk9STUFULCB0cnVlKTtcblxuICAgICAgICAgICAgaWYgKCFtb21lbnREYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm93LnZhbHVlW3RoaXMuY29sdW1uLmlkXSA9ICBuZXdEYXRlVmFsdWUudmFsdWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucm93LnZhbHVlW3RoaXMuY29sdW1uLmlkXSA9IGAke21vbWVudERhdGUuZm9ybWF0KCdZWVlZLU1NLUREJyl9VDAwOjAwOjAwLjAwMFpgO1xuICAgICAgICAgICAgICAgIHRoaXMudGFibGUuZmx1c2hWYWx1ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLyogcmVtb3ZlcyB0aGUgZGF0ZSAgKi9cbiAgICAgICAgICAgIHRoaXMucm93LnZhbHVlW3RoaXMuY29sdW1uLmlkXSA9ICcnO1xuICAgICAgICB9XG4gICAgfVxuXG59XG4iXX0=