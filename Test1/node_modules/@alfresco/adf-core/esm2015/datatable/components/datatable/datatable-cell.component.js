/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ChangeDetectionStrategy, Component, Input, ViewEncapsulation } from '@angular/core';
import { AlfrescoApiService } from '../../../services/alfresco-api.service';
import { BehaviorSubject, Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
export class DataTableCellComponent {
    /**
     * @param {?} alfrescoApiService
     */
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.value$ = new BehaviorSubject('');
        this.onDestroy$ = new Subject();
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        this.updateValue();
        this.alfrescoApiService.nodeUpdated
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((/**
         * @param {?} node
         * @return {?}
         */
        node => {
            if (this.row) {
                if (this.row['node'].entry.id === node.id) {
                    this.row['node'].entry = node;
                    this.row['cache'][this.column.key] = this.column.key.split('.').reduce((/**
                     * @param {?} source
                     * @param {?} key
                     * @return {?}
                     */
                    (source, key) => source[key]), node);
                    this.updateValue();
                }
            }
        }));
    }
    /**
     * @protected
     * @return {?}
     */
    updateValue() {
        if (this.column && this.column.key && this.row && this.data) {
            /** @type {?} */
            const value = this.data.getValue(this.row, this.column);
            this.value$.next(value);
            if (!this.tooltip) {
                this.tooltip = value;
            }
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
DataTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span *ngIf="copyContent; else defaultCell"
                adf-clipboard="CLIPBOARD.CLICK_TO_COPY"
                [clipboard-notification]="'CLIPBOARD.SUCCESS_COPY'"
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
                >{{ value$ | async }}</span>
        </ng-container>
        <ng-template #defaultCell>
            <span
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
            >{{ value$ | async }}</span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell' }
            }] }
];
/** @nocollapse */
DataTableCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
DataTableCellComponent.propDecorators = {
    data: [{ type: Input }],
    column: [{ type: Input }],
    row: [{ type: Input }],
    copyContent: [{ type: Input }],
    tooltip: [{ type: Input }]
};
if (false) {
    /**
     * Data table adapter instance.
     * @type {?}
     */
    DataTableCellComponent.prototype.data;
    /**
     * Data that defines the column.
     * @type {?}
     */
    DataTableCellComponent.prototype.column;
    /**
     * Data that defines the row.
     * @type {?}
     */
    DataTableCellComponent.prototype.row;
    /** @type {?} */
    DataTableCellComponent.prototype.value$;
    /**
     * Enables/disables a Clipboard directive to allow copying of the cell's content.
     * @type {?}
     */
    DataTableCellComponent.prototype.copyContent;
    /**
     * Text for the cell's tooltip.
     * @type {?}
     */
    DataTableCellComponent.prototype.tooltip;
    /**
     * @type {?}
     * @protected
     */
    DataTableCellComponent.prototype.onDestroy$;
    /**
     * @type {?}
     * @protected
     */
    DataTableCellComponent.prototype.alfrescoApiService;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0YXRhYmxlLWNlbGwuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Im5nOi8vQGFsZnJlc2NvL2FkZi1jb3JlLyIsInNvdXJjZXMiOlsiZGF0YXRhYmxlL2NvbXBvbmVudHMvZGF0YXRhYmxlL2RhdGF0YWJsZS1jZWxsLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWlCQSxPQUFPLEVBQ0gsdUJBQXVCLEVBQ3ZCLFNBQVMsRUFDVCxLQUFLLEVBRUwsaUJBQWlCLEVBRXBCLE1BQU0sZUFBZSxDQUFDO0FBSXZCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQzVFLE9BQU8sRUFBRSxlQUFlLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQ2hELE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQTBCM0MsTUFBTSxPQUFPLHNCQUFzQjs7OztJQXlCL0IsWUFBc0Isa0JBQXNDO1FBQXRDLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7UUFaNUQsV0FBTSxHQUFHLElBQUksZUFBZSxDQUFNLEVBQUUsQ0FBQyxDQUFDO1FBVTVCLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO0lBRWlCLENBQUM7Ozs7SUFFaEUsUUFBUTtRQUNKLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUNuQixJQUFJLENBQUMsa0JBQWtCLENBQUMsV0FBVzthQUM5QixJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQzthQUNoQyxTQUFTOzs7O1FBQUMsSUFBSSxDQUFDLEVBQUU7WUFDZCxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUU7Z0JBQ1YsSUFBSSxJQUFJLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxFQUFFLEtBQUssSUFBSSxDQUFDLEVBQUUsRUFBRTtvQkFDdkMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO29CQUM5QixJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU07Ozs7O29CQUFDLENBQUMsTUFBTSxFQUFFLEdBQUcsRUFBRSxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxHQUFFLElBQUksQ0FBQyxDQUFDO29CQUMzRyxJQUFJLENBQUMsV0FBVyxFQUFFLENBQUM7aUJBQ3RCO2FBQ0o7UUFDTCxDQUFDLEVBQUMsQ0FBQztJQUNYLENBQUM7Ozs7O0lBRVMsV0FBVztRQUNqQixJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEdBQUcsSUFBSSxJQUFJLENBQUMsSUFBSSxFQUFFOztrQkFDbkQsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQztZQUV2RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQztZQUV4QixJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtnQkFDZixJQUFJLENBQUMsT0FBTyxHQUFHLEtBQUssQ0FBQzthQUN4QjtTQUNKO0lBQ0wsQ0FBQzs7OztJQUVELFdBQVc7UUFDUCxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUMzQixJQUFJLENBQUMsVUFBVSxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQy9CLENBQUM7OztZQWpGSixTQUFTLFNBQUM7Z0JBQ1AsUUFBUSxFQUFFLG9CQUFvQjtnQkFDOUIsZUFBZSxFQUFFLHVCQUF1QixDQUFDLE1BQU07Z0JBQy9DLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FpQlQ7Z0JBQ0QsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7Z0JBQ3JDLElBQUksRUFBRSxFQUFFLEtBQUssRUFBRSw0QkFBNEIsRUFBRTthQUNoRDs7OztZQTNCUSxrQkFBa0I7OzttQkE4QnRCLEtBQUs7cUJBSUwsS0FBSztrQkFJTCxLQUFLOzBCQU1MLEtBQUs7c0JBSUwsS0FBSzs7Ozs7OztJQWxCTixzQ0FDdUI7Ozs7O0lBR3ZCLHdDQUNtQjs7Ozs7SUFHbkIscUNBQ2E7O0lBRWIsd0NBQXNDOzs7OztJQUd0Qyw2Q0FDcUI7Ozs7O0lBR3JCLHlDQUNnQjs7Ozs7SUFFaEIsNENBQThDOzs7OztJQUVsQyxvREFBZ0QiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LFxuICAgIENvbXBvbmVudCxcbiAgICBJbnB1dCxcbiAgICBPbkluaXQsXG4gICAgVmlld0VuY2Fwc3VsYXRpb24sXG4gICAgT25EZXN0cm95XG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0YUNvbHVtbiB9IGZyb20gJy4uLy4uL2RhdGEvZGF0YS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRGF0YVJvdyB9IGZyb20gJy4uLy4uL2RhdGEvZGF0YS1yb3cubW9kZWwnO1xuaW1wb3J0IHsgRGF0YVRhYmxlQWRhcHRlciB9IGZyb20gJy4uLy4uL2RhdGEvZGF0YXRhYmxlLWFkYXB0ZXInO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvYWxmcmVzY28tYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyB0YWtlVW50aWwgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLWRhdGF0YWJsZS1jZWxsJyxcbiAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8bmctY29udGFpbmVyPlxuICAgICAgICAgICAgPHNwYW4gKm5nSWY9XCJjb3B5Q29udGVudDsgZWxzZSBkZWZhdWx0Q2VsbFwiXG4gICAgICAgICAgICAgICAgYWRmLWNsaXBib2FyZD1cIkNMSVBCT0FSRC5DTElDS19UT19DT1BZXCJcbiAgICAgICAgICAgICAgICBbY2xpcGJvYXJkLW5vdGlmaWNhdGlvbl09XCInQ0xJUEJPQVJELlNVQ0NFU1NfQ09QWSdcIlxuICAgICAgICAgICAgICAgIFthdHRyLmFyaWEtbGFiZWxdPVwidmFsdWUkIHwgYXN5bmNcIlxuICAgICAgICAgICAgICAgIFt0aXRsZV09XCJ0b29sdGlwXCJcbiAgICAgICAgICAgICAgICBjbGFzcz1cImFkZi1kYXRhdGFibGUtY2VsbC12YWx1ZVwiXG4gICAgICAgICAgICAgICAgPnt7IHZhbHVlJCB8IGFzeW5jIH19PC9zcGFuPlxuICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgPG5nLXRlbXBsYXRlICNkZWZhdWx0Q2VsbD5cbiAgICAgICAgICAgIDxzcGFuXG4gICAgICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJ2YWx1ZSQgfCBhc3luY1wiXG4gICAgICAgICAgICAgICAgW3RpdGxlXT1cInRvb2x0aXBcIlxuICAgICAgICAgICAgICAgIGNsYXNzPVwiYWRmLWRhdGF0YWJsZS1jZWxsLXZhbHVlXCJcbiAgICAgICAgICAgID57eyB2YWx1ZSQgfCBhc3luYyB9fTwvc3Bhbj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgaG9zdDogeyBjbGFzczogJ2FkZi1kYXRhdGFibGUtY29udGVudC1jZWxsJyB9XG59KVxuZXhwb3J0IGNsYXNzIERhdGFUYWJsZUNlbGxDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XG4gICAgLyoqIERhdGEgdGFibGUgYWRhcHRlciBpbnN0YW5jZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIGRhdGE6IERhdGFUYWJsZUFkYXB0ZXI7XG5cbiAgICAvKiogRGF0YSB0aGF0IGRlZmluZXMgdGhlIGNvbHVtbi4gKi9cbiAgICBASW5wdXQoKVxuICAgIGNvbHVtbjogRGF0YUNvbHVtbjtcblxuICAgIC8qKiBEYXRhIHRoYXQgZGVmaW5lcyB0aGUgcm93LiAqL1xuICAgIEBJbnB1dCgpXG4gICAgcm93OiBEYXRhUm93O1xuXG4gICAgdmFsdWUkID0gbmV3IEJlaGF2aW9yU3ViamVjdDxhbnk+KCcnKTtcblxuICAgIC8qKiBFbmFibGVzL2Rpc2FibGVzIGEgQ2xpcGJvYXJkIGRpcmVjdGl2ZSB0byBhbGxvdyBjb3B5aW5nIG9mIHRoZSBjZWxsJ3MgY29udGVudC4gKi9cbiAgICBASW5wdXQoKVxuICAgIGNvcHlDb250ZW50OiBib29sZWFuO1xuXG4gICAgLyoqIFRleHQgZm9yIHRoZSBjZWxsJ3MgdG9vbHRpcC4gKi9cbiAgICBASW5wdXQoKVxuICAgIHRvb2x0aXA6IHN0cmluZztcblxuICAgIHByb3RlY3RlZCBvbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCBhbGZyZXNjb0FwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSkge31cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgIHRoaXMuYWxmcmVzY29BcGlTZXJ2aWNlLm5vZGVVcGRhdGVkXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobm9kZSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm93KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJvd1snbm9kZSddLmVudHJ5LmlkID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd1snbm9kZSddLmVudHJ5ID0gbm9kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucm93WydjYWNoZSddW3RoaXMuY29sdW1uLmtleV0gPSB0aGlzLmNvbHVtbi5rZXkuc3BsaXQoJy4nKS5yZWR1Y2UoKHNvdXJjZSwga2V5KSA9PiBzb3VyY2Vba2V5XSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgdXBkYXRlVmFsdWUoKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbiAmJiB0aGlzLmNvbHVtbi5rZXkgJiYgdGhpcy5yb3cgJiYgdGhpcy5kYXRhKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGF0YS5nZXRWYWx1ZSh0aGlzLnJvdywgdGhpcy5jb2x1bW4pO1xuXG4gICAgICAgICAgICB0aGlzLnZhbHVlJC5uZXh0KHZhbHVlKTtcblxuICAgICAgICAgICAgaWYgKCF0aGlzLnRvb2x0aXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXAgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxufVxuIl19