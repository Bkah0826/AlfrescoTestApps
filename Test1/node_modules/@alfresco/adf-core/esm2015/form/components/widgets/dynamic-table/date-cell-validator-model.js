/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* tslint:disable:component-selector  */
import moment from 'moment-es6';
export class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    /**
     * @param {?} column
     * @return {?}
     */
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    /**
     * @param {?} row
     * @param {?} column
     * @param {?=} summary
     * @return {?}
     */
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            /** @type {?} */
            const value = row.value[column.id];
            if (!value && !column.required) {
                return true;
            }
            /** @type {?} */
            const dateValue = moment(value, 'YYYY-MM-DDTHH:mm:ss.SSSSZ', true);
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    DateCellValidator.prototype.supportedTypes;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS1jZWxsLXZhbGlkYXRvci1tb2RlbC5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BhbGZyZXNjby9hZGYtY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL2R5bmFtaWMtdGFibGUvZGF0ZS1jZWxsLXZhbGlkYXRvci1tb2RlbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFtQkEsT0FBTyxNQUFNLE1BQU0sWUFBWSxDQUFDO0FBTWhDLE1BQU0sT0FBTyxpQkFBaUI7SUFBOUI7UUFFWSxtQkFBYyxHQUFhO1lBQy9CLE1BQU07U0FDVCxDQUFDO0lBMkJOLENBQUM7Ozs7O0lBekJHLFdBQVcsQ0FBQyxNQUEwQjtRQUNsQyxPQUFPLE1BQU0sSUFBSSxNQUFNLENBQUMsUUFBUSxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztJQUN0RixDQUFDOzs7Ozs7O0lBRUQsUUFBUSxDQUFDLEdBQW9CLEVBQUUsTUFBMEIsRUFBRSxPQUFxQztRQUU1RixJQUFJLElBQUksQ0FBQyxXQUFXLENBQUMsTUFBTSxDQUFDLEVBQUU7O2tCQUNwQixLQUFLLEdBQUcsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDO1lBRWxDLElBQUksQ0FBQyxLQUFLLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxFQUFFO2dCQUM1QixPQUFPLElBQUksQ0FBQzthQUNmOztrQkFFSyxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSwyQkFBMkIsRUFBRSxJQUFJLENBQUM7WUFDbEUsSUFBSSxDQUFDLFNBQVMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtnQkFDdEIsSUFBSSxPQUFPLEVBQUU7b0JBQ1QsT0FBTyxDQUFDLE9BQU8sR0FBRyxLQUFLLENBQUM7b0JBQ3hCLE9BQU8sQ0FBQyxPQUFPLEdBQUcsWUFBWSxNQUFNLENBQUMsSUFBSSxXQUFXLENBQUM7aUJBQ3hEO2dCQUNELE9BQU8sS0FBSyxDQUFDO2FBQ2hCO1NBQ0o7UUFFRCxPQUFPLElBQUksQ0FBQztJQUNoQixDQUFDO0NBQ0o7Ozs7OztJQTdCRywyQ0FFRSIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIHRzbGludDpkaXNhYmxlOmNvbXBvbmVudC1zZWxlY3RvciAgKi9cblxuaW1wb3J0IG1vbWVudCBmcm9tICdtb21lbnQtZXM2JztcbmltcG9ydCB7IENlbGxWYWxpZGF0b3IgfSBmcm9tICcuL2NlbGwtdmFsaWRhdG9yLm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNSb3dWYWxpZGF0aW9uU3VtbWFyeSB9IGZyb20gJy4vZHluYW1pYy1yb3ctdmFsaWRhdGlvbi1zdW1tYXJ5Lm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZUNvbHVtbiB9IGZyb20gJy4vZHluYW1pYy10YWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlUm93IH0gZnJvbSAnLi9keW5hbWljLXRhYmxlLXJvdy5tb2RlbCc7XG5cbmV4cG9ydCBjbGFzcyBEYXRlQ2VsbFZhbGlkYXRvciBpbXBsZW1lbnRzIENlbGxWYWxpZGF0b3Ige1xuXG4gICAgcHJpdmF0ZSBzdXBwb3J0ZWRUeXBlczogc3RyaW5nW10gPSBbXG4gICAgICAgICdEYXRlJ1xuICAgIF07XG5cbiAgICBpc1N1cHBvcnRlZChjb2x1bW46IER5bmFtaWNUYWJsZUNvbHVtbik6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gY29sdW1uICYmIGNvbHVtbi5lZGl0YWJsZSAmJiB0aGlzLnN1cHBvcnRlZFR5cGVzLmluZGV4T2YoY29sdW1uLnR5cGUpID4gLTE7XG4gICAgfVxuXG4gICAgdmFsaWRhdGUocm93OiBEeW5hbWljVGFibGVSb3csIGNvbHVtbjogRHluYW1pY1RhYmxlQ29sdW1uLCBzdW1tYXJ5PzogRHluYW1pY1Jvd1ZhbGlkYXRpb25TdW1tYXJ5KTogYm9vbGVhbiB7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTdXBwb3J0ZWQoY29sdW1uKSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByb3cudmFsdWVbY29sdW1uLmlkXTtcblxuICAgICAgICAgICAgaWYgKCF2YWx1ZSAmJiAhY29sdW1uLnJlcXVpcmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRhdGVWYWx1ZSA9IG1vbWVudCh2YWx1ZSwgJ1lZWVktTU0tRERUSEg6bW06c3MuU1NTU1onLCB0cnVlKTtcbiAgICAgICAgICAgIGlmICghZGF0ZVZhbHVlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChzdW1tYXJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN1bW1hcnkuaXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdW1tYXJ5Lm1lc3NhZ2UgPSBgSW52YWxpZCAnJHtjb2x1bW4ubmFtZX0nIGZvcm1hdC5gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iXX0=